import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/visitor.dart';
import 'package:build/build.dart';
import 'package:source_gen/source_gen.dart';
import 'dart:async';
import 'class_visitor.dart';
import 'util.dart';

/// Wrapps a ClassVisitor (delegate) and overrides each visited method
/// where only the method body has to be returned form the delegate.
/// The method declaration is generated by this visitor.
class OverrideClassVisitor extends ClassVisitor<FutureOr<String>> {
  final ClassVisitor<FutureOr<String>> delegate;
  OverrideClassVisitor(this.delegate) : super();

  @override
  Future<String> get classDeclaration => delegate.classDeclaration;

  @override
  visitClassElement(ClassElement element) {
    return delegate.visitClassElement(element);
  }

  @override
  visitMethodElement(MethodElement element) async {
    return _generateMethod(element, delegate.visitMethodElement(element));
  }

  @override
  visitPropertyAccessorElement(PropertyAccessorElement element) async {
    return _generateMethod(
        element, delegate.visitPropertyAccessorElement(element));
  }

  @override
  visitFieldElement(FieldElement element) async {
    return delegate.visitFieldElement(element);
  }

  @override
  visitConstructorElement(ConstructorElement element) {
    return delegate.visitConstructorElement(element);
  }

  Future<String> _generateMethod(
      ExecutableElement element, FutureOr<String> body) async {
    String declaration = generateDeclaration(element);
    String bodyText = await body;
    if (bodyText == null) return null;
    return '''$declaration $bodyText''';
  }
}

String generateDeclaration(ExecutableElement element) {
  String argumentDeclarations = generateArgumentDeclarations(element);

  bool isSetter = element is PropertyAccessorElement && element.isSetter;
  bool isGetter = element is PropertyAccessorElement && element.isGetter;

  StringBuffer output = new StringBuffer();
  if (isSetter) {
    output.write('set ');
  } else {
    output.write(element.returnType.toString() + ' ');
  }
  if (isGetter) output.write(' get ');
  output.write(element.displayName);
  if (!isGetter) {
    output.write(' ( ');
    output.write(argumentDeclarations);
    output.write(' ) ');
  }
  output.write(element.isAsynchronous ? ' async ' : '');
  return output.toString();
}

String generateArgumentDeclarations(ExecutableElement element) {
  bool hasNamedArgs = element.parameters.any((p) => p.isNamed);
  bool hasPositionalArgs =
      element.parameters.any((p) => p.isPositional && p.isOptional);
  if (hasNamedArgs && hasPositionalArgs) {
    log.severe('named and positional arguments $element');
  }
  String argumentEncoder(Iterable<ParameterElement> elements) =>
      elements.map((p) => '${p.type.name} ${p.name}').join(', ');
  String declarationRequiredArguments =
      argumentEncoder(element.parameters.where((p) => p.isNotOptional));
  String declarationPositionalArguments = argumentEncoder(
      element.parameters.where((p) => p.isPositional && p.isOptional));
  String declarationNamedArguments =
      argumentEncoder(element.parameters.where((p) => p.isNamed));
  String argumentDeclarations = declarationRequiredArguments;
  if ((hasNamedArgs || hasPositionalArgs) &&
      declarationRequiredArguments.isNotEmpty) argumentDeclarations += ', ';
  if (hasPositionalArgs) {
    argumentDeclarations += '[' + declarationPositionalArguments + ']';
  }
  if (hasNamedArgs) {
    argumentDeclarations += '{' + declarationNamedArguments + '}';
  }

  return argumentDeclarations;
}

overrideWith(ClassElement element, ClassVisitor<String> visitor) async {
  visitor.visitClassElement(element);
  String impl =
      new OverrideClassVisitor(visitor).visitAllExecutables(element).join('\n');
  return (await visitor.classDeclaration) + '{' + impl + '}';
}
